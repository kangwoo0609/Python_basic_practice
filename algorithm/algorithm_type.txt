### 여러가지 알고리즘

- 문제를 보고 "이 알고리즘을 쓰면 되겠구나~" 를 판단해야 함
  - 어느 정도 순서가 있다.

1. 완전 탐색 (brute force)
- 나올 수 있는 모든 경우를 다 돌려보자
- 동전 거스름돈: 500, 100, 50, 10
  -> 최소한의 동전 개수로 3000원을 만들어보자.
  -> 모든 경우의 수를 다 돌려보는 것

안 될 것 같은데 ? ==> 시간 복잡도, 공간 복잡도

2. 규칙 같은거 없을까? (탐욕 알고리즘 - Greedy)
- 현재 단계에서 제일 좋은 것만 골랐을 때, 최종적으로 정답이 나오는 알고리즘
- 동전 거스름돈: 500, 100, 50, 10
  -> 최소한의 동전 개수로 3000원을 만들어보자.
  -> 최소한 -> 값이 큰 동전부터 계산하는 게 좋을 것이다.

3240 (500, 100, 50, 10)
- 500원: 3,000원 -> 240원 남음
- 100원: 200원 -> 40원 남음
- 10원: 40원 -> 4개 끝

180원, 240원, 10원 -> 그리디로 못 푼다. (규칙으로 해결이 안됨)
360원

3. 동적 프로그래밍 (DP: Dynamic Programming)
- 한 번이라도 계산해놨던 작업은 두 번 하지 않겠다
  - 저장해두고 가져다 쓰겠다
  -> 수학을 잘하는 사람들이 잘함 (점화식을 짜는 방식으로 구현)
  -> or 재귀호출을 잘하면 되긴 한다.


### 카운팅 정렬

1. 왜 굳이 값을 누적할까 ?
  - 누적된 값: 데이터가 어디에 삽입되어야 한다는 위치값
  - 튜플 기준으로 해보면 제대로 된 결과를 낼 수 없다.

2. 왜 굳이 뒤에서부터 연산할까 ?
  - 앞에서 부터 연산할 경우
    동일한 key값이라면, 순서가 뒤집어진다.
  - 안정 정렬 -> 항상 똑같은 동작을 한다.
  - 불안정 정렬
    - 튜플 기준으로 생각

둘 모두 숫자 하나로는 오류가 나지 않는다.